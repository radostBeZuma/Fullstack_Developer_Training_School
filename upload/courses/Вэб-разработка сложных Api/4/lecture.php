<h4>Асинхронность</h4>
<p>Синхронные операции — операции, при которых мы получаем результат в результате блокирования потока выполнения. Для простых вычислительных операций (сложение/умножение чисел) — это единственный вариант их совершения, для операций ввода/вывода — один из, при этом мы говорим, к примеру, «попытайся прочитать из файла что-нибудь за 100мс», и если для чтения ничего нет — поток выполнения будет заблокирован на эти 100мс.</p>
<p>В некоторых случаях это допустимо (например, если мы делаем простое консольное приложение, либо какую-либо утилиту, цель которой — отработать и всё), но в некоторых — нет. К примеру, если мы так застрянем в потоке, в котором обрабатывается UI — наше приложение зависнет. За примерами далеко ходить не нужно — если javascript на сайте сделает while(true);, то перестанут вызываться какие-либо другие обработчики событий страницы и её придётся закрыть. Те же дела, если начать что-нибудь вычислять под Android'ом в обработчиках UI-событий (код которых вызывается в UI-потоке), это приведёт к появлению окна «приложение не отвечает, закрыть?» (подобные окна вызываются по watchdog-таймеру, который сбрасывается, когда выполнение возвращается обратно к системе UI).</p>
<p>Асинхронные операции — операции, при которых мы просим совершить некоторую операцию и можем каким-либо образом отслеживать процесс/результат её выполнения. Когда она будет выполнена — неизвестно, но мы можем продолжить заниматься другими делами.</p>
<h4>Event loop</h4>
<p>Event loop — это бесконечный цикл, который берёт события из очереди и как-то их обрабатывает. А в некоторых промежутках — смотрит, не произошло ли каких-нибудь IO-событий, либо не просрочились ли какие-либо таймеры — тогда добавляет в очередь событие об этом, чтобы потом обработать.</p>
<p>Вернёмся к примеру с браузером. Вся страница работает в одном event loop'е, загруженный страницей javascript добавляется в очередь, чтобы выполниться. Если на странице происходят какие-либо UI-события (клик по кнопке, перемещение мыши, прочее) — код их обработчиков добавляется в очередь. Обработчики выполняются последовательно, нет никакой параллельности, пока работает какой-либо код — все остальные ждут. Если какой-нибудь код вызовет какую-нибудь специальную функцию, вроде setTimeout(function() { alert(42) }, 5000) — то это создаст где-то вне цикла таймер, по истечению которого в очередь будет добавлен код функции с alert(42).</p>
<p>Фишка: если кто-то в очереди перед выполнением обработчика будет что-то долго вычислять, то обработчик таймера, очевидно, выполнится позже, чем через пять секунд.</p>
<p>Вторая фишка: даже если мы попросим, например, 1 миллисекунду ожидания, может пройти куда больше, т.к. реализация event loop'а может посмотреть: «ага, очередь пуста, ближайший таймер через 1мс, будем ждать IO-событий 1мс», а когда мы вызовем select, реализация операционной системы может посмотреть: «ага, событий вроде нет, на твоё время мне всё равно, я делаю context switch, пока есть возможность», а там все остальные потоки заиспользовали всё доступное им время и мы пролетели.</p>
<h4>select</h4>
<p>Асинхронные IO-события на низком уровне реализованы при помощи вариаций select'а. У нас есть некие файловые дескрипторы (которые могут быть либо файлами, либо сетевыми сокетами, либо чем-то ещё (по сути, в Linux что угодно может являться файлом (или наоборот, файл может являться чем угодно))).</p>
<p>И мы можем вызвать некоторую синхронную функцию, передав ей множество дескрипторов, от которых мы ожидаем ввода, либо же хотим что-то записать, которая заблокирует поток до тех пор пока:</p>
<p>
	1. Один или несколько переданных нами дескрипторов не станут готовы к совершению желаемой нами операции. </br>
	2. Не истекло время ожидания (если оно было задано).
</p>
<p>В результате выполнения этой процедуры мы получим множества готовых к чтению/записи файлов.</p>
<h4>Callbacks</h4>
<p>Самый простой способ получить результаты выполнения асинхронной операции — при её создании передать ссылки на функции, которые будут вызваны при каком-либо прогрессе выполнения/готовности результата.</p>
<p>Это довольно низкоуровневый подход, и часто неумение банально писать функции «в столбик» вместе со злоупотреблением анонимных функций приводит к «callback hell» (ситуация, когда мы имеем четыре-десять уровней вложенности функций, чтобы обработать последовательные операции):</p>
<div class="console">
	<p class="console-text">// Вкладываем</p>
	<p class="console-text">function someAsync(a, callback) {</p>
	<p class="console-text tab">anotherAsync(a, function(b) {</p>
	<p class="console-text tab-t">asyncAgain(b, function(c) {</p>
	<p class="console-text tab-3">andAgain(b, c, function(d) {</p>
	<p class="console-text tab-4">lastAsync(d, callback);</p>
	<p class="console-text tab-3">});</p>
	<p class="console-text tab-t">});</p>
	<p class="console-text tab">});</p>
	<p class="console-text">}</p>

	<p class="console-text">// Линейно</p>
	<p class="console-text">function someAsync2(a, callback) {</p>
	<p class="console-text tab">var b;</p>
	<p></p>
	<p class="console-text tab">anotherAsync(a, handleAnother);</p>
	<p></p>
	<p class="console-text tab">function handleAnother(_b) {</p>
	<p class="console-text tab-t">b = _b;</p>
	<p class="console-text tab-t">asyncAgain(b, handleAgain);</p>
	<p class="console-text tab">}</p>
	<p></p>
	<p class="console-text tab">function handleAgain(c) {</p>
	<p class="console-text tab-t">andAgain(b, c, handleAnd);</p>
	<p class="console-text tab">}</p>
	<p></p>
	<p class="console-text tab">function handleAnd(d) {</p>
	<p class="console-text tab-t">lastAsync(d, callback);</p>
	<p class="console-text tab">}</p>
	<p class="console-text">}</p>
</div>
<h4>Async Monad</h4>
<p>Мы, программисты, любим абстрагировать и обобщать для сокрытия разных сложностей/рутины. Поэтому существует, в том числе, абстракция над асинхронными вычислениями.</p>
<p>Что такое «вычисление»? Это процесс преобразования A в B. Будем записывать синхронные вычисления как A → B.</p>
<p>Что такое «асинхронное значение»? Это обещание предоставить нам в будущем некоторое значение T (которое может быть успешным результатом, либо ошибкой). Будем обозначать это как Async[T].</p>
<p>Тогда «асинхронная операция» будет выглядеть как A → Async[T], где A — какие-то аргументы, необходимые для старта операции (например, это может быть URL, к которому мы хотим совершить GET-запрос).</p>
<p>Как работать с Async[T]? Пусть у него будет метод run, который примет коллбэк, который будет вызван тогда, когда данные станут доступны: Async[T].run : (T → ()) → () (принимает функцию, принимающую T, ничего не возвращает).</p>
<p>Хорошо, а теперь добавим самое главное — возможность продолжить асинхронную операцию. Если у нас есть Async[A], то, очевидно, когда A станет доступно, мы можем создать Async[B] и ждать уже его результата. Функция для такого продолжения будет выглядеть так:</p>
<p>Async[A].then : (A → Async[B]) → Async[B]</p>
<p>Т.е. если мы можем создать Async[B] из некого A, а так же имеем Async[A], который когда-нибудь предоставит нам A, нет никаких проблем предоставить Async[B] сразу, ибо B мы сможем всё-таки получить через какое-то время и в итоге всё сойдётся.</p>









